/*
 * Contact Listener Controller Class
 *
 * Manage collisions between RigidBodies in a box2D world
 *
 * Copyright 2014-2017, Kibble Games. All Rights Reserved.
 */
'use strict';

import {Physics} from '../lib/Physics.js';

class ContactListener {
    
    constructor( theWorld ) {        
        /*
         * Don't create or destroy any PHYSICS entities in these event handlers, store the info to
         * manage in an update later.
         *
         * The Contact object is generated by Box2D to contain the collision info
         * It also contains a method to get the two fixtures that collided
         * Use them to inspect the user data.
         *
         * its key that the user data have info identifying the dom element so you can manipulate.
         *
         */
        this.m_listener = new Physics.Listener;
        
        // Set function redirects for Physics system "contact listeners"
        this.m_listener.PreSolve = this.preSolve;

        this.m_listener.BeginContact = this.beginContact;
        this.m_listener.EndContact = this.endContact;
        
        this.m_listener.PostSolve = this.postSolve;

        theWorld.SetContactListener( this.m_listener );
    }
    
    preSolve( contact, oldManifold ) {
        //
        // PreSolve
        //
        // This is called after collision detection, but before collision resolution.
        // This gives you a chance to disable the contact based on the current configuration.
        //
    }

    beginContact( contact ) {
        //
        // console.log(contact.GetFixtureA().GetBody().GetUserData());
        //
        // This is called when two fixtures begin to overlap.
        //
        let thingA = contact.GetFixtureA().GetBody().GetUserData();
        let thingB = contact.GetFixtureB().GetBody().GetUserData();

        if ((thingA == null) || (thingB == null))
            return;

        let idA = thingA.$element.attr('id');
        let idB = thingB.$element.attr('id');

        if ((idA == 'piggie') || (idB == 'piggie')) {
            console.log("Obstacle was hit by the pig");            
        }
    }

    endContact( contact ) {
        //
        // console.log(contact.GetFixtureA().GetBody().GetUserData());
        //
        // This is called when two fixtures cease to overlap.
        //
    }
    
    postSolve( contact, impulse ) {
        //
        // PostSolve
        //
        // The post solve event is where you can gather collision impulse results. If you donï¿½t care about the impulses,
        // you should probably just implement the pre-solve event.
        //
        //if (contact.GetFixtureA().GetBody().GetUserData() == 'ball' || contact.GetFixtureB().GetBody().GetUserData() == 'ball') {
        //
        //    console.log(world.ball.impulse);
        //}
        let thingA = contact.GetFixtureA().GetBody().GetUserData();
        let thingB = contact.GetFixtureB().GetBody().GetUserData();

        if ((thingA == null) || (thingB == null))
            return;

        if (thingA.$element.hasClass('id') == 'bird1') {
            // possible win, we have a bird
            // possible wall, if its the ceiling win?
        }
    }    
}