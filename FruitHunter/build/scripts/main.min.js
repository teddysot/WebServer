/*
	Fruit Hunter Game - Apple Object
	Made using Box2d and Jquery on the Html5 Canvas element
	
    Original code by : Silver Moon (m00n.silv3r@gmail.com)
    Adaptation to ES8 modules and classes by Scott Henshaw (shenshaw@vfs.com)   
	
	Enjoy!!
*/
'use strict';

import { Asset } from './init.js';
import { Physics } from './box2d.js';

export class Apple {
    
    constructor( options ) {
        this.height = 0.25;
        this.width = 0.25;
        this.x = options.x;
        this.y = options.y;
        
        this.game = options.game;
        
        var linear_damping = 10 - (parseInt(this.game.points / 10) + 1)*0.5;
        
        var info = { 
            'density' : 10 ,
            'linearDamping' : linear_damping ,
            'fixedRotation' : true ,
            'userData' : this ,
            'type' : Physics.b2Body.b2_dynamicBody ,
        };
        
        var body = Physics.createBox( this.game.box2d_world , this.x, this.y, this.width, this.height, info );
        this.body = body;
        this.img = Asset.load('apple.png');
    }

    render() {
        
        if (this.body == null)
            return false;
        
        //draw_body(this.body, this.game.ctx);       
        let c = this.game.get_offset( this.body.GetPosition() );
        
        let scale = this.game.scale;
        
        let sx = c.x * scale;
        let sy = c.y * scale;
        
        let width = this.width * scale;
        let height = this.height * scale;
        
        this.game.ctx.translate( sx, sy );
        this.game.ctx.drawImage( this.img , -width / 2, -height / 2, width, height );
        this.game.ctx.translate( -sx, -sy );
    }

    update() {

        this.age++;
        
        //destroy the apple if it falls below the x axis
        if (this.body.GetPosition().y < 0) {
            this.game.destroy_object(this);
        }
    }

    //Destroy the apple when player eats it
    destroy() {

        if (this.body == null)
            return;
        
        this.body.GetWorld().DestroyBody( this.body );
        this.body = null;
        this.dead = true;
    }
}
/*
box2d docs at http://www.box2dflash.org/docs/2.1a/reference/
*/
'use strict';



class PhysicsLib {

	constructor() {

		// Alias' for functions from Box2D
		this.b2Vec2 = Box2D.Common.Math.b2Vec2;
		this.b2AABB = Box2D.Collision.b2AABB;
	
		this.b2BodyDef =    Box2D.Dynamics.b2BodyDef;
		this.b2Body =       Box2D.Dynamics.b2Body;
		this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
		this.b2Fixture =    Box2D.Dynamics.b2Fixture;
		
		this.b2World = Box2D.Dynamics.b2World;
		
		this.b2MassData =    Box2D.Collision.Shapes.b2MassData;
		
		this.b2PolygonShape =	 Box2D.Collision.Shapes.b2PolygonShape;
		this.b2CircleShape =	 Box2D.Collision.Shapes.b2CircleShape;
		this.b2DebugDraw =	 Box2D.Dynamics.b2DebugDraw;
		this.b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;
		this.b2Shape =        Box2D.Collision.Shapes.b2Shape;
	
		this.b2RevoluteJointDef =	 Box2D.Dynamics.Joints.b2RevoluteJointDef;
		this.b2Joint =            Box2D.Dynamics.Joints.b2Joint;
		this.b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef;
		this.b2ContactListener =  Box2D.Dynamics.b2ContactListener;
	
		this.b2Settings =	Box2D.Common.b2Settings;
		this.b2Mat22 =	Box2D.Common.Math.b2Mat22;
	
		this.b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef;
		this.b2EdgeShape =   Box2D.Collision.Shapes.b2EdgeShape;
	
		this.b2WorldManifold = Box2D.Collision.b2WorldManifold;

		this.setSpeed();
	}

	setSpeed() {
		//max speed = 10 mps for higher velocity
		this.b2Settings.b2_maxTranslation = 10.0;
		this.b2Settings.b2_maxRotation = 50.0;
	}

	createBox( world, x, y, width, height, options ) {
		//default setting
		options = $.extend(true, {
			'density' : 1.0 ,
			'friction' : 1.0 ,
			'restitution' : 0.0 ,
			
			'linearDamping' : 0.0 ,
			'angularDamping' : 0.0 ,
			
			'gravityScale' : 1.0 ,
			'type' : this.b2Body.b2_dynamicBody , 
			
			'fixedRotation' : false ,
		}, options);
		
		var body_def = new this.b2BodyDef();
		var fix_def = new this.b2FixtureDef();
		
		fix_def.density = options.density;
		fix_def.friction = options.friction;
		fix_def.restitution = options.restitution;
		
		fix_def.shape = new this.b2PolygonShape();
		
		//user specific data
		fix_def.userData = options.userData;
		
		//important! this takes half the width
		fix_def.shape.SetAsBox( width /2 , height /2 );
		
		body_def.position.Set(x , y);
		body_def.linearDamping = options.linearDamping;
		body_def.angularDamping = options.angularDamping;
		
		body_def.type = options.type;
		body_def.fixedRotation = options.fixedRotation;
		
		var b = world.CreateBody( body_def );
		var f = b.CreateFixture(fix_def);
		
		return b;
	}

	//Generic function to draw a box2d body , with a given shape on a given context
	drawShape( game, body , shape, context ) {

		context.strokeStyle = '#000';
		context.lineWidth = 1;
		let scale = game.scale;
		
		context.fillStyle = "#ccc";
		
		context.beginPath();
		switch (shape.GetType()) 
		{
			//A polygon type shape like a square , rectangle etc
			case this.b2Shape.e_polygonShape:			
				let vert = shape.GetVertices();
				let position = body.GetPosition();
				//b2Math.MulMV(b.m_xf.R , vert[0]);
				
				let tV = position.Copy();
				let a = vert[0].Copy();
				a.MulM( body.GetTransform().R );
				
				tV.Add(a);
				
				let _v = game.get_offset( tV );
				
				let _x = _v.x;
				let _y = _v.y;
				
				context.moveTo( _x * scale, _y * scale );
				
				for (let i = 0; i < vert.length; i++) {
					//Get a copy of the vertice
					let v = vert[i].Copy();
					
					//Rotate the vertice
					v.MulM( body.GetTransform().R );
					
					v.Add(position);
					
					//Subtract the camera coordinates to get relative offsets
					let _v = game.get_offset(v);
					
					let _x1 = _v.x;
					let _y1 = _v.y;

					//Draw line to the new point
					context.lineTo( _x1 * scale , _y1  * scale);
				}
				context.lineTo(_x * scale, _y * scale);			
				break;

			default:
				break;
		}
		
		context.fill();
		context.stroke();
	}

	//Draw a body by drawing all the shapes of its fixtures
	drawBody( game, body, context ) {
		let c_x = body.GetWorldCenter().x;
		let c_y = body.GetWorldCenter().y;
		
		for (let f = body.GetFixtureList() ; f != null ; f = f.GetNext()) {
			let shape = f.GetShape();
			
			//draw the shape finally
			this.drawShape( game, body , shape , context );
		}
	}
}

/**
	1. Initialise the box2d objects
	2. Code for class inheritance
*/
export const Physics = new PhysicsLib();



/*
	Fruit Hunter Game
	Made using Box2d and Jquery on the Html5 Canvas element
	
    Original code by : Silver Moon (m00n.silv3r@gmail.com)
    Adaptation to ES8 modules and classes by Scott Henshaw (shenshaw@vfs.com)   
	
	Enjoy!!
*/
'use strict';

import { Asset } from './init.js';
import { Physics } from './box2d.js';

import { Wall } from   './wall.js';
import { Apple } from  './apple.js';
import { Player } from './player.js';

const KEY = {
	LEFT:  37,
	UP:    38,
	RIGHT: 39,
	A:     65,
	W:     87,
	D:     68,
    SPACE: 32
}

export class Game {

	constructor() {
		this.fps = 60;
		this.scale = 50;
		
		//global array of all objects to manage
		this.game_objects = [];
		
		this.points = 0;
		this.to_destroy = [];
		this.time_elapsed = 0;
	}

	resize() {

		let canvas = this.canvas;
		
		//Set the canvas dimensions to match the window dimensions
		let w = $(window).outerWidth();
		let h = $(window).outerHeight();
		
		canvas.width(w);
		canvas.height(h);
		
		canvas.attr('width' , w * 0.75);
		canvas.attr('height' , h * 0.75);
		
		this.canvas_width = canvas.attr('width');
		this.canvas_height = canvas.attr('height');
		
		this.screen_height = 10;
		this.scale = this.canvas_height / this.screen_height;
		this.screen_width = this.canvas_width / this.scale;
	}

	setup() {

		let $canvas = $('#canvas');
		let ctx = this.ctx = $canvas.get(0).getContext('2d');
		this.canvas = $canvas;
		
		//resize to correct size
		this.resize();
		
		//dimensions in metres
		let w = this.screen_width;
		let h = this.screen_height;
			
		//create the box2d world
		this.create_box2d_world();
		
		//lower slab
		this.game_objects.push( new Wall({ x: w/2 - 3.5, y: 1, width: 2, height: 1, game: this }));
		this.game_objects.push( new Wall({ x: w/2,       y: 1, width: 2, height: 1, game: this }));
		this.game_objects.push( new Wall({ x: w/2 + 3.5, y: 1, width: 2, height: 1, game: this }));
		
		//the player
		this.player = new Player({ x: w/2, y: h/2, game: this });
		this.game_objects.push(this.player);
		
		//attach event handlers for key presses
		this.start_handling();
		
		//setup collision handler too
		this.setup_collision_handler();
	}

	create_box2d_world() {
		//10m/s2 downwards, cartesian coordinates remember - we shall keep slightly lesser gravity
		let gravity = new Physics.b2Vec2( 0, -10 );
		
		/*
		very important to do this, otherwise player will not move.
		basically dynamic bodies trying to slide over static bodies will go to sleep
		*/
		let doSleep = false;
		this.box2d_world = new Physics.b2World( gravity, doSleep );
	}

	//Start the game :) Setup and start ticking the clock
	start()	{
		this.on = true;
		this.total_points = 0;
		
		this.setup();
		this.is_paused = false;
		
		//Start the Game Loop - TICK TOCK TICK TOCK TICK TOCK TICK TOCK
		this.update();
	}

	restart() {

		// clean up all the old physics objects before restarting
		for (let element of this.game_objects) {
			this.box2d_world.DestroyBody( element.body );
		}
		this.game_objects.length = 0;  // clobber the existing game objects, let the GC collect it up.		
		Physics.setSpeed();            // Reset the speed values
		this.start();
	}

	redraw_world() {
		//1. clear the canvas first - not doing this will cause tearing at world ends
		this.ctx.clearRect( 0 , 0 , this.canvas_width , this.canvas_height );
		
		//dimensions in metres
		let w = this.screen_width;
		let h = this.screen_height;
		
		let img = Asset.load('orange_hills.png');
		this.ctx.drawImage( img, 0 , 0 , this.canvas_width, this.canvas_height );
		
		img = Asset.load('tree.png');
		this.ctx.drawImage( img,  (w/2 - 4.5) * this.scale , h/2 , 10 * this.scale, this.canvas_height );
		
		Asset.write({ x: 25, y: 25, font:'bold 15px arial', color:'#fff', text:'Fruits '+ this.points, ctx: this.ctx });
		
		//Draw each object one by one , the tiles , the cars , the other objects lying here and there
		for(let i in this.game_objects)
		{
			this.game_objects[i].render();
		}
	}

	update( count )	{

		if (!this.is_paused && this.on) {
			
			this.time_elapsed += 1;
			
			//create a random fruit on top
			if(this.time_elapsed % 50 == 0) {

				let xc = Math.random() * 8 + this.screen_width/2 - 4;
				let yc = this.screen_height/2 + 2.5;
				
				this.game_objects.push( new Apple({ x: xc, y: yc, game: this }));
			}
			
			//tick all objects, if dead then remove
			for (let i in this.game_objects)	{

				if (this.game_objects[i].dead == true) {

					delete this.game_objects[i];
					continue; // bad...
				}
				
				this.game_objects[i].update();
			}
			
			//garbage collect dead things
			this.perform_destroy();
			
			//Step the box2d engine ahead
			this.box2d_world.Step(1/20 , 8 , 3);
			
			//important to clear forces, otherwise forces will keep applying
			this.box2d_world.ClearForces();
			
			//redraw the world
			this.redraw_world();
			
			if(!this.is_paused && this.on) {

				// [SH] Convert to requestAnimationFrame
				//game.fps times in 1000 milliseconds or 1 second
				this.timer = setTimeout( () => { 

					this.update(); 
				}, 1000/this.fps);
			}
		}
	}

	perform_destroy() {

		for (let i in this.to_destroy) {

			this.to_destroy[i].destroy();
		}
	}

	get_offset( vector ) {

		return new Physics.b2Vec2( vector.x - 0, Math.abs( vector.y - this.screen_height ));
	}

	start_handling() {

		$(document).on('keydown.game', event => {
			this.key_down( event );
			return false;
		});
		
		$(document).on('keyup.game', event => {
			this.key_up( event );
			return false;
		});
	}

	key_down( event ) {
		
		switch ( event.keyCode ) {
			case KEY.LEFT:
			case KEY.A:
				this.player.do_move_left = true;
				break;
		
			case KEY.UP:
			case KEY.W:
			case KEY.SPACE:
				this.player.jump();
				break;
		
			case KEY.RIGHT:
			case KEY.D:
				this.player.do_move_right = true;
				break;

			default:
				// do nothing
				break;
		}
	}

	key_up( event )	{
		
		switch ( event.keyCode ) {
			case KEY.LEFT:
			case KEY.A:
				this.player.do_move_left = false;
				break;

			case KEY.UP:
			case KEY.W:
			case KEY.SPACE:
				this.player.do_move_up = false;
				this.player.can_move_up = true;
				break;

			case KEY.RIGHT:
			case KEY.D:
				this.player.do_move_right = false;
				break;

			default:
				// do nothing
				break;
		}
	}

	//Setup collision handler
	setup_collision_handler() {
		
		//Override a few functions of class b2ContactListener
		Physics.b2ContactListener.prototype.BeginContact = ( contact ) => {
			//now come action time
			let a = contact.GetFixtureA().GetUserData();
			let b = contact.GetFixtureB().GetUserData();
			if (a instanceof Player && b instanceof Apple) {

				this.destroy_object( b );
				this.points++;
			}
			
			else if (b instanceof Player && a instanceof Apple) {

				this.destroy_object( a );
				this.points++;
			}
			//apple hits a wall
			else if (a instanceof Apple && b instanceof Wall)
			{
				this.destroy_object( a );
			}
		}
	}

	//schedule an object for destruction in next tick
	destroy_object( obj ) {
		this.to_destroy.push( obj );
	}
}	
'use strict';

export class Asset {
	/* 
	Load image from asset manager 
	Asset.img_res( path )
	*/
	static load( path ) {

		let i = new Image();
		i.src = 'images/'+path;
		
		return i;
	}

	/* Generic function to write text 
	example :
		Asset.write_text( options );
		
		where options = { 
			x : game.canvas_width - 100 , 
			y : game.canvas_height - 50 , 
			font : 'bold 35px arial' , 
			color : '#fff' , 
			text : time , 
			ctx : game.ctx
		}
	*/
	static write( options ) {
		var x = options.x;
		var y = options.y;
		var font = options.font;
		var color = options.color;
		var text = options.text;
		var ctx = options.ctx;
	
		ctx.save();
		if ('shadow' in options)	{

			ctx.shadowColor = options.shadow.color;
			ctx.shadowOffsetX = options.shadow.x;
			ctx.shadowOffsetY = options.shadow.y;
			ctx.shadowBlur = options.shadow.blur;
		}
		
		ctx.font = font;
		/*ctx.textAlign = 'center';*/
		ctx.fillStyle = color;		
		if ('align' in options)	{

			ctx.textAlign = options.align;
		}	
		ctx.fillText( text , x , y);
		ctx.restore();
	}
}

/*
	Fruit Hunter Game
	Made using Box2d and Jquery on the Html5 Canvas element
	
    Original code by : Silver Moon (m00n.silv3r@gmail.com)
    Adaptation to ES8 modules and classes by Scott Henshaw (shenshaw@vfs.com)   
	
	Enjoy!!
*/
'use strict';

import { Game } from './game.js';

$(document).ready( event => {

	let game = new Game();
	
	//store game pointer in a global object
	//global_game = game;	
	$(window).resize( event => { game.resize();	});
	game.start();
});
/*
	Fruit Hunter Game - Player Object
	Made using Box2d and Jquery on the Html5 Canvas element
	
    Original code by : Silver Moon (m00n.silv3r@gmail.com)
    Adaptation to ES8 modules and classes by Scott Henshaw (shenshaw@vfs.com)   
	
	Enjoy!!
*/
'use strict';

import { Asset } from './init.js';
import { Physics } from './box2d.js';


/*
Player object monkey art from
http://www.vickiwenderlich.com/2011/06/game-art-pack-monkey-platformer/
*/
export class Player {

    constructor(options) {

		this.height = 1.0;
		this.width = 0.66;
		
		this.x = options.x;
		this.y = options.y;
		this.game = options.game;
		this.age = 0;
			
		this.do_move_left = false;
		this.do_move_right = false;
		this.max_hor_vel = 2;
		this.max_ver_vel = 4;
		this.can_move_up = true;
		
		var info = { 
			'density':       10,
			'fixedRotation': true,
			'userData':      this,
			'type':          Physics.b2Body.b2_dynamicBody,
			'restitution':   0.0,
		};
		
		var body = Physics.createBox( this.game.box2d_world , this.x, this.y, this.width, this.height, info );
		this.body = body;
		this.img = Asset.load('monkey.png');
	}

	update() {
		if (this.is_out()) {
			//turn off the game
			this.game.on = false;			
			this.game.restart();
		}
		
		if(this.do_move_left) { 
			this.add_velocity(new Physics.b2Vec2(-1,0));
		}
		
		if(this.do_move_right) {
			this.add_velocity(new Physics.b2Vec2(1,0));
		}
		
		if(this.do_move_up && this.can_move_up) {
			
			this.add_velocity(new Physics.b2Vec2(0,6));
			this.can_move_up = false;
		}
		
        this.age++;
        //this.img = Asset.load('monkey.png');
	}

	add_velocity( vel ) {

		var b = this.body;
		var v = b.GetLinearVelocity();
		
		v.Add(vel);
		
		//check for max horizontal and vertical velocities and then set
		if (Math.abs(v.y) > this.max_ver_vel) {
			v.y = this.max_ver_vel * v.y/Math.abs(v.y);
		}
		
		if (Math.abs(v.x) > this.max_hor_vel) {
			v.x = this.max_hor_vel * v.x/Math.abs(v.x);
		}
		
		//set the new velocity
		b.SetLinearVelocity( v );
	}

	render() {
		if (this.body == null)
			return false;
		
		//Physics.drawBody( this.game, this.body, this.game.ctx );
		
		let c = this.game.get_offset( this.body.GetPosition() );
		let scale = this.game.scale;
		let sx = c.x * scale;
		let sy = c.y * scale;
		
		let width = this.width * scale;
		let height = this.height * scale;
		
		this.game.ctx.translate( sx, sy );
		this.game.ctx.drawImage( this.img, -width / 2, -height / 2, width, height );
		this.game.ctx.translate(-sx, -sy );
	}

	jump() {
		//if player is already in vertical motion, then cannot jump
		if (Math.abs( this.body.GetLinearVelocity().y ) > 0.0)
			return false;
		
		this.do_move_up = true;
	}

	is_out() {
		//if player has fallen below the 0 level of y axis in the box2d coordinates, then he is out
		if (this.body.GetPosition().y < 0)
			return true;
		
		return false;
	}
}


/*
	Fruit Hunter Game - Wall object
	Made using Box2d and Jquery on the Html5 Canvas element
	
    Original code by : Silver Moon (m00n.silv3r@gmail.com)
    Adaptation to ES8 modules and classes by Scott Henshaw (shenshaw@vfs.com)   
	
	Enjoy!!
*/
'use strict';

import { Asset } from './init.js';
import { Physics } from './box2d.js';

export class Wall {

    constructor( options ) {

		this.x = options.x;
		this.y = options.y;
		
		this.height = options.height;
		this.width = options.width;
		
		this.game = options.game;
		this.age = 0;
		//create a box2d static object - one that does not move, but does collide with dynamic objects
		
		let info = { 
			'density':       10 ,
			'fixedRotation': true ,
			'userData':      this ,
			'type':          Physics.b2Body.b2_staticBody ,
		};
		
		let body = Physics.createBox( this.game.box2d_world , this.x, this.y, this.width, this.height, info );
		this.body = body;
		this.img = Asset.load('wall.png');
	}

	update() {
		this.age++;
	}

	//Draw bricks
	render() {
		//draw_body(this.body, this.game.ctx);
		
		let x1 = this.x - this.width/2;
		let x2 = this.x + this.width/2;
		
		let y1 = this.y + this.height/2;
		let y2 = this.y - this.height/2;
		
		let scale = this.game.scale;
		
		let width = 1.0 * scale;
		let height = 1.0 * scale;
		
        this.img = Asset.load('wall.png');
		for(let i = x1 ; i < x2; i++) {

			for(let j = y1; j > y2; j--) {

				//get canvas coordinates
				let c = this.game.get_offset( new Physics.b2Vec2( i, j ) );
				this.game.ctx.drawImage( this.img, c.x * scale, c.y * scale, width, height );
			}
		}
	}
}